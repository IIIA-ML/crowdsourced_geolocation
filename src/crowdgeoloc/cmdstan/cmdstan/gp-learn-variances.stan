data {
  int<lower=1> Nk; // Number of points known
  int<lower=1> r; // Number of repetitions for each point
  array[r,Nk] real xk; // Positions of the points reported
  int<lower=1> Nu; // Number of points unknown
  array[Nu] real xu; // Positions of the points unknown
  real alpha; // Controls the spread of the functions generated by the GP. The smaller the alpha, the smaller the range in y's.
  real rho;   // Controls the variability of the functions generated by the GP. The smaller the rho, the larger the variability.
  //real sigma; // Controls the randomness of the functions. The larger the sigma, the less continuous the generated functions.
  real log_sd_0;  // The initial value for the standard deviation
}

transformed data {
  int<lower=1> N = Nk + Nu;

  vector[N] mu_log_sd = rep_vector(log_sd_0, N);

  real delta = 1e-9;
}

parameters {
    vector[Nk] log_sd; // Logarithm of the standard deviation for annotated points
    array[Nk] real xk_r; // Positions of the annotated points
    vector[N] log_sd_real; // Logarithm of the standard deviation for all points
    real<lower=0> sigma;
}

model {
    print("sigma=",sigma);
    array[N] real x;
    print("xk_r=",xk_r);
    //print("sd=",exp(log_sd));
    //print("sd_real=",exp(log_sd_real));
    //((xk_r+rep_array(0.2,Nk))/1.4) ~ beta(2,2);
    for (r_ in 1:r) {
        xk[r_,:] ~ normal(xk_r, exp(log_sd));
    }
    for (nk in 1:Nk) {
        x[nk] = xk_r[nk];
    }
    for (nu in 1:Nu) {
        x[Nk + nu] = xu[nu];
    }
    matrix[N, N] K = gp_exp_quad_cov(x, alpha, rho) + diag_matrix(rep_vector(delta , N));
    //matrix[N, N] K1 = cov_exp_quad(x, alpha, rho) + diag_matrix(rep_vector(delta , N));
    //print(K-K1);
    //target += multi_normal_lpdf(log(sd) | mu_sd, K);

    log_sd_real ~ multi_normal(mu_log_sd, K);
    log_sd ~ normal(log_sd_real[1:Nk], sigma);
}